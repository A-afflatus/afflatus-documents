---
title: Java模块化
---
# Java模块化介绍
## 1. 什么是模块化
模块化是一种软件设计的方法，它的目的是将大型程序分解为可维护和可重用的小模块。无论是JavaScript模块化还是Java模块化，它们都是为了解决以下问题：

- **代码复用性：** 模块化可以使代码更易于重用和共享。相同的代码可以在多个项目中使用，从而减少了代码的冗余
  > 如maven模块化
- **命名冲突：** 在大型程序中，变量和函数的命名容易冲突，导致程序出现错误。使用模块化可以将变量和函数封装在模块中，避免了命名冲突的问题
  > java有访问修饰符来修饰类与类之间的开放关系,而传统的js并没有，在多js依赖同时引用的情况下很可能出现命名冲突，js为此也做了很多针对性的演化如:命名空间、闭包引用、再到后来的模块化
- **代码维护性：** 将程序分解为小模块可以使程序更易于维护。如果程序需要修改，只需要修改相应的模块，而不需要修改整个程序，模块和模块之间的是松耦合的，模块之前靠抽象定义互通访问，无需关注内部变化。
- **依赖管理：** 大型程序通常依赖于其他库和框架。模块化可以使依赖关系更加清晰，更容易管理。
::: tip 总结
模块化是将代码和依赖项组织成清晰边界、可重用和可维护的单元的过程，以更好地控制应用程序的依赖关系和减少应用程序的大小和复杂性。
:::
## 2. 什么是Java模块化

Java模块化所解决的主要问题和js略有不同，随着java生态20几年的发展，java已经逐渐成为一门臃肿的语言，内部依赖关系也变得极其复杂，为此java模块化诞生了

Java模块化是Java 9中引入的新特性，它允许开发人员将代码分解为可重用的模块，这些模块可以更轻松地管理、测试和维护。模块是一组相关的类、接口和资源文件的集合，其内部可以定义公共API，以供其他模块访问。

使用Java模块化可以提高应用程序的可扩展性和可维护性，使得应用程序更易于构建和部署。每个模块都可以声明其所需的依赖项，并将其暴露给其他模块，从而使得应用程序的依赖关系更加清晰明了。

Java模块化还引入了新的访问控制机制，使得开发人员可以更细粒度地控制模块之间的访问权限。此外，模块化还可以提高应用程序的安全性，因为只有明确授权的模块才能访问另一个模块的代码和资源。
## 3. 一个🌰
考虑一个名为 ServiceMonitor 的应用程序。忽略细节，它的行为大致如下：通过网络
检查其他服务的可用性并聚合统计信息。这些统计信息被写入数据库，并通过 REST API 对外提
供服务。
该应用程序创建了 4 个 JAR。
- observer——观察其他服务并检查可用性。
- statistics——把可用性数据聚合成统计信息。
- persistence——通过 hibernate 把统计信息读写到数据库。
- monitor——触发数据收集，并将数据从 statistics 一路发送到 persistence，采用 spark
实现 REST API。
![java模块化之后程序启动流程.png](/images/java模块化/ServiceMonitor例子.png)
由于历史版本的java对jar的定义只是一个类容器，所以导致开发者精心设计的结构最终在JVM中变成一团乱麻
![java模块化之后程序启动流程.png](/images/java模块化/大泥球.png)

## 4. 模块化之前面临的问题

1. **jar与jar之前的访问控制缺失**

java的四种访问修饰符都是对当前项目内部做访问权限控制，但是对于外部包，则是要么完全封闭要么完全开放;
从而导致由于项目目录结构，我们不得不将某些实现类声明称public，但是这是外部就有途径直接调用实现类，而不是我们规定好的抽象接口，这样显然是不满足开发者预期的，使用者直接使用实现类会在后续迭代中持续存在下游jar修改实现逻辑的风险

2. **松散的合约关系**

之前，java对于jar的概念只是装有类文件的容器，不关心jar与jar之间的关系(也就是maven中所谓的artifact工件)，使得所有的类都处于一种混沌状态，任何公有类型都可以互相访问，所以开发者通常需要maven等依赖管理工具来管理工件级别的依赖，明切jar之间的依赖关系

与上文的访问控制缺失问题相同，我们可以越过抽象接口，直接使用其实现类，虽然这在编程规范中并不合理，日常开发中我们也会尽量避免这种情况的发生，但编译器纬度并不限制调用，更不会禁止直接调用抽象的实现；
在jdk纬度的开发包中，这种情况会反向限制开发者对代码的迭代，开发者无法轻易的删除任何一行老的代码，java模块化从计划到落地的10多年里这项是复杂度的主要来源

3. **JAR地狱**

"jar地狱"是指在Java项目中，存在大量的jar包依赖，导致项目的维护和部署变得非常复杂和困难的现象。这种情况通常会出现在使用许多第三方库的项目中，每一个库都需要引入自己的jar包，并且这些jar包之间可能存在版本冲突，导致项目无法正常运行。

当项目中存在大量的jar包依赖时，会导致以下问题：

- 项目部署变得非常困难。由于需要将所有的依赖jar包都打包到项目中，导致项目的大小变得非常庞大，部署和传输时间也会变得非常长。
- 项目的维护变得非常困难。由于存在大量的jar包依赖，当需要更新其中一个依赖时，可能会涉及到其他依赖的变更，这会导致整个项目的重构和测试工作。
- 运行时出现问题变得非常困难。由于存在大量的jar包依赖，当出现问题时，需要逐一排查每一个依赖的版本和兼容性问题，这会耗费大量的时间和精力。

> 通常会借助Maven、Gradle等构建工具来管理依赖并维护jar之间的依赖关系

4.**大泥球**

从main开始jvm每次加载未知的类都需要根据她的完全限定名便利classpath下所有的类，然后将找到的类加载到一个巨大的类集合中，这时就是没有模块概念导致的，编译的时候不清楚模块间的依赖，运行的时候也同样，导致所有的类都被放到了一个命名空间，也就是所谓的“大泥球”，这样使我们精心设计好的依赖关系到最终运行的时候编程一团乱麻

5.**缓慢的加载**

java启动满体量大被人们长期诟病，而java启动慢的主要原因是类的加载，java对类的扫描加载是线性的，极端情况下会扫描整个class path下的类文件,
类文件越多加载也就越慢，然而我们在引入一个第三方包之后并不一定需要包下的所有类文件，可能只需要其中一个，但由于没有引入的是一整个jar包，可能导致我们多余的加载我们实际需要n倍的类文件;
同时线性加载可能会导致一些难以预测的副作用，比如jar冲突、影子类等

## 5. 模块化的解决的问题
在jdk9之后JDK被分为大概100个平台模块，在类的上层有提出了一切皆模块的概念，无论是在编译器还是运行期，java都始终保持对模块结构的审查
![java模块化之后程序启动流程.png](/images/java模块化/JDK模块化.png)
**一个模块化之后的例子**
> 我们建立一个mu.xml的应用，并通过module-info.java声明她的模块依赖关系
```java:no-line-numbers
module my.xml.app {
 requires java.base; 
 requires java.xml;
 exports my.xml.api;
} 
```
该应用声明了对java.base和java.xml平台模块的依赖，并对外暴露包路径为my.xml.api的包(注意这是包)，那么该应用的加载启动在模块化的夹持下将会变为如下步骤：
1. 自启动。
2. 验证所需的模块都存在。
3. 构建应用程序架构的内部描述。
4. 启动初始模块的 main 函数。
5. 在应用程序执行过程中持续运行以保护模块内部。
![java模块化之后程序启动流程.png](/images/java模块化/java模块化之后程序启动流程.png)
步骤2和4就可以摆脱以往"大泥球"式的加载逻辑了

## 6. 模块化🌰
**现在我们将上文的例子用模块化的方式进行描述**
![模块化的ServiceMonitor.png](/images/java模块化/模块化的ServiceMonitor.png)
::: tip 注意⚠️
这及是依赖图也是模块系统对应用的呈现
:::

附录：[Java模块化关键字一览](/Java/Java模块化/Java模块化关键字.md)
